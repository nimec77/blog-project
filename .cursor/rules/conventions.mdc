---
alwaysApply: true
---
# Code Conventions

> Reference: All architectural decisions are in [vision.md](./vision.md). This document covers code-level rules only.

---

## Core Principle

**KISS** â€” Write the simplest code that works. No abstractions until needed twice.

---

## Code Style

### Imports Order

```rust
// 1. Standard library
use std::sync::Arc;

// 2. External crates
use tokio::sync::RwLock;
use tonic::{Request, Response, Status};
use tracing::info;

// 3. Internal modules
use crate::domain::User;
use crate::application::AuthService;
```

### Naming

| Type | Convention | Example |
|------|------------|---------|
| Structs | PascalCase | `UserRepository`, `BlogService` |
| Functions | snake_case | `find_by_id`, `create_post` |
| Constants | SCREAMING_SNAKE | `DEFAULT_LIMIT`, `MAX_TITLE_LEN` |
| Modules | snake_case | `http_handlers`, `grpc_service` |

### Module System

Use the **new module style** (Rust 2018+): `module.rs` instead of `module/mod.rs`.

```
# Good (new style)
src/
â”œâ”€â”€ domain.rs          # declares submodules
â””â”€â”€ domain/
    â”œâ”€â”€ user.rs
    â””â”€â”€ post.rs

# Bad (old style) â€” DO NOT USE
src/
â””â”€â”€ domain/
    â”œâ”€â”€ mod.rs         # âŒ avoid
    â”œâ”€â”€ user.rs
    â””â”€â”€ post.rs
```

### Function Signatures

```rust
// Good: clear, typed, documented
/// Creates a new post for the given author.
pub async fn create_post(
    &self,
    author_id: i64,
    req: CreatePostRequest,
) -> Result<Post, AppError> {
    // ...
}

// Bad: unclear, no docs
pub async fn create(&self, id: i64, r: Req) -> Result<P, E> { }
```

---

## Error Handling

### One Error Enum Per Crate

```rust
// domain/error.rs
#[derive(Debug, thiserror::Error)]
pub enum AppError {
    #[error("User not found")]
    UserNotFound,
    
    #[error("Post not found")]
    PostNotFound,
    
    #[error("Invalid credentials")]
    InvalidCredentials,
    
    #[error("Forbidden")]
    Forbidden,
    
    #[error("Database error: {0}")]
    Database(#[from] sqlx::Error),
    
    #[error("JWT error: {0}")]
    Jwt(#[from] jsonwebtoken::errors::Error),
}
```

### Error Propagation

```rust
// Good: use ? operator
pub async fn get_post(&self, id: i64) -> Result<Post, AppError> {
    let post = self.repo.find_by_id(id).await?
        .ok_or(AppError::PostNotFound)?;
    Ok(post)
}

// Bad: manual matching everywhere
pub async fn get_post(&self, id: i64) -> Result<Post, AppError> {
    match self.repo.find_by_id(id).await {
        Ok(Some(post)) => Ok(post),
        Ok(None) => Err(AppError::PostNotFound),
        Err(e) => Err(AppError::Database(e)),
    }
}
```

---

## Validation

### Validate at Boundaries Only

```rust
// Good: validate in handler, trust internal code
async fn create_post(
    auth: AuthenticatedUser,
    req: web::Json<CreatePostRequest>,
) -> Result<impl Responder, AppError> {
    // Validate here
    if req.title.is_empty() {
        return Err(AppError::ValidationError("Title required".into()));
    }
    
    // Service trusts input is valid
    let post = service.create_post(auth.user_id, req.into_inner()).await?;
    Ok(HttpResponse::Created().json(post))
}

// Bad: re-validate in every layer
impl BlogService {
    pub async fn create_post(&self, ...) -> Result<Post> {
        if req.title.is_empty() { // Redundant!
            return Err(...);
        }
    }
}
```

---

## Logging

### Use Structured Logging

```rust
// Good: structured fields
tracing::info!(
    user_id = %user.id,
    username = %user.username,
    "User registered"
);

// Bad: string interpolation
println!("User registered: {} {}", user.id, user.username);
```

### Never Log Sensitive Data

```rust
// Good
tracing::info!(username = %req.username, "Login attempt");

// Bad â€” NEVER do this
tracing::info!(password = %req.password, "Login attempt");
```

---

## Testing

### Test File Location

```rust
// Unit tests: same file
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_post_new() {
        let post = Post::new(1, "Title".into(), "Content".into());
        assert_eq!(post.title, "Title");
    }
}

// Integration tests: tests/ folder
// tests/api_tests.rs
```

### Async Tests

```rust
#[tokio::test]
async fn test_create_post() {
    let pool = setup_test_db().await;
    let service = BlogService::new(pool);
    
    let post = service.create_post(1, CreatePostRequest {
        title: "Test".into(),
        content: "Content".into(),
    }).await.unwrap();
    
    assert_eq!(post.title, "Test");
}
```

### Test Naming

```rust
// Pattern: test_<function>_<scenario>
#[test]
fn test_post_new_creates_with_current_timestamp() { }

#[test]
fn test_post_new_fails_with_empty_title() { }
```

---

## Architecture Patterns

### Config Returns Result

```rust
// Good: returns Result, caller decides how to handle
impl AppConfig {
    pub fn from_env() -> Result<Self, AppError> {
        dotenvy::dotenv().ok();
        let database_url = std::env::var(ENV_DATABASE_URL)
            .map_err(|_| AppError::Config("DATABASE_URL must be set".into()))?;
        Ok(Self { database_url, ... })
    }
}

// In main.rs
let config = AppConfig::from_env().expect("invalid configuration");
```

### Database Functions Return Result

```rust
// Good: separate functions, return Result
pub async fn create_pool(database_url: &str) -> Result<SqlitePool, sqlx::Error> {
    SqlitePoolOptions::new()
        .max_connections(DB_MAX_CONNECTIONS)
        .connect(database_url)
        .await
}

pub async fn run_migrations(pool: &SqlitePool) -> Result<(), sqlx::Error> {
    sqlx::migrate!().run(pool).await
}
```

### Repository Trait Pattern

```rust
// Trait for testability
#[async_trait]
pub trait UserRepository: Send + Sync {
    async fn find_by_id(&self, id: i64) -> Result<Option<User>, AppError>;
    async fn find_by_username(&self, username: &str) -> Result<Option<User>, AppError>;
    async fn create(&self, username: &str, email: &str, hash: &str) -> Result<User, AppError>;
}

// Implementation
#[derive(Clone)]
pub struct SqliteUserRepository {
    pool: SqlitePool,
}

#[async_trait]
impl UserRepository for SqliteUserRepository { ... }
```

### Services Use Arc for Dependencies

```rust
// Good: Arc for shared ownership
pub struct AuthService<R: UserRepository> {
    repo: Arc<R>,
    jwt_keys: JwtKeys,
}

impl<R: UserRepository> AuthService<R> {
    pub fn new(repo: Arc<R>, jwt_keys: JwtKeys) -> Self {
        Self { repo, jwt_keys }
    }
}
```

### Handler Route Macros and Scopes

```rust
// Good: use actix-web route macros
#[post("/auth/register")]
async fn register(
    service: web::Data<AuthService>,
    payload: web::Json<RegisterRequest>,
) -> Result<impl Responder, AppError> {
    let response = service.register(payload.into_inner()).await?;
    Ok(HttpResponse::Created().json(response))
}

// Handler module returns a scope
pub fn public_routes() -> Scope {
    web::scope("")
        .service(health)
        .service(register)
        .service(login)
}

// In main.rs: nest scopes under /api
HttpServer::new(move || {
    App::new()
        .app_data(web::Data::new(auth_service.clone()))
        .service(web::scope("/api").service(public_routes()))
})
```

### Use #[instrument] for Tracing

```rust
use tracing::instrument;

#[instrument(skip(self, password))]
pub async fn login(&self, email: &str, password: &str) -> Result<String, AppError> {
    // Function calls are automatically traced
}
```

---

## What NOT To Do

| Don't | Do Instead |
|-------|------------|
| `unwrap()`/`expect()` in runtime code | `?` or explicit error handling |
| `println!` for logging | `tracing::info!`, `tracing::error!` |
| Nested `if-else` chains | Early returns with `?` |
| Magic numbers | Named constants |
| Comments explaining *what* | Self-documenting code |
| Over-abstracting | Abstractions only when needed twice |
| `clone()` everywhere | Borrow when possible |
| Panics in libraries | Return `Result` |
| Panic in config/DB functions | Return `Result`, panic only in `main()` |

---

## File Size Limits

| Threshold | Action |
|-----------|--------|
| < 200 lines | âœ… Good |
| 200-400 lines | âš ï¸ Consider splitting |
| > 400 lines | ðŸ”´ Must split |

---

## Commit Messages

```
<type>: <short description>

Types: feat, fix, refactor, test, docs, chore
```

Examples:
- `feat: add user registration endpoint`
- `fix: handle empty post title validation`
- `refactor: extract JWT logic to separate module`

---

## Quick Checklist

Before committing:

- [ ] No `unwrap()`/`expect()` in runtime code (startup init is OK)
- [ ] No `println!` (use tracing)
- [ ] Public functions have `///` doc comments
- [ ] Tests for happy path + one error case
- [ ] No sensitive data in logs
- [ ] Imports organized (std â†’ external â†’ internal)
- [ ] File under 400 lines

